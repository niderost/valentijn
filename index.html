
<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Cupidâ€™s Aim ðŸ’˜</title>
  <style>
    :root{
      --bg1:#0b0b14;
      --bg2:#1b1030;
      --card:#ffffff12;
      --text:#f6f3ff;
      --muted:#cfc6ffcc;
      --accent:#ff4d8d;
      --accent2:#ffb3d0;
      --good:#7CFFB2;
      --warn:#ffd36e;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 30% 20%, #2a1a55 0%, transparent 55%),
        radial-gradient(1000px 700px at 80% 30%, #3a1036 0%, transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow:hidden;
      touch-action:none; /* important for aiming on mobile */
    }

    .wrap{
      position:relative;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
    }

    .hud{
      position:absolute;
      top:10px;
      left:10px;
      right:10px;
      display:flex;
      gap:10px;
      align-items:stretch;
      justify-content:space-between;
      pointer-events:none;
    }

    .pill{
      pointer-events:none;
      background:var(--card);
      border:1px solid #ffffff22;
      backdrop-filter: blur(10px);
      border-radius:999px;
      padding:10px 12px;
      display:flex;
      gap:10px;
      align-items:center;
      box-shadow: 0 10px 30px #00000040;
      min-width: 0;
    }

    .pill strong{font-weight:700}
    .pill .muted{color:var(--muted); font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .pill .value{font-variant-numeric: tabular-nums; white-space:nowrap;}
    .pill .dot{
      width:10px; height:10px; border-radius:50%;
      background: #ffffff40;
      box-shadow: 0 0 0 3px #ffffff10;
      flex:0 0 auto;
    }
    .pill.good .dot{background:var(--good); box-shadow:0 0 0 3px #7cffb21a}
    .pill.warn .dot{background:var(--warn); box-shadow:0 0 0 3px #ffd36e1a}

    .panel{
      position:absolute;
      bottom:10px;
      left:10px;
      right:10px;
      display:flex;
      justify-content:center;
      pointer-events:none;
    }

    .instructions{
      pointer-events:none;
      max-width: 680px;
      width:100%;
      background:var(--card);
      border:1px solid #ffffff22;
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:12px 14px;
      box-shadow: 0 10px 30px #00000040;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .instructions .emoji{font-size:22px; line-height:1}
    .instructions .txt{font-size:14px; color:var(--muted)}
    .instructions .txt b{color:var(--text)}

    canvas{
      width:min(520px, 96vw);
      height:min(820px, 92vh);
      border-radius:22px;
      background: linear-gradient(180deg, #0b0b14 0%, #130b25 45%, #1b1030 100%);
      border:1px solid #ffffff20;
      box-shadow: 0 20px 60px #00000080;
    }

    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      pointer-events:none;
    }

    .modal{
      pointer-events:auto;
      max-width: 720px;
      width: min(720px, 92vw);
      background: #0f0a1de6;
      border:1px solid #ffffff22;
      border-radius:22px;
      box-shadow: 0 20px 80px #000000aa;
      padding:18px;
      backdrop-filter: blur(12px);
    }

    .modal h1{
      margin: 0 0 8px;
      font-size: 22px;
      letter-spacing: .2px;
    }
    .modal p{margin: 8px 0; color: var(--muted); line-height:1.35}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px}
    .btn{
      appearance:none;
      border:1px solid #ffffff26;
      background: #ffffff14;
      color: var(--text);
      padding: 11px 14px;
      border-radius: 14px;
      font-weight: 700;
      cursor:pointer;
      transition: transform .05s ease;
    }
    .btn:active{transform: scale(.98)}
    .btn.primary{
      background: linear-gradient(180deg, #ff4d8d, #ff2d76);
      border-color: #ff7cab55;
    }

    .finalCard{
      margin-top:12px;
      padding:14px;
      border-radius:18px;
      border:1px solid #ffffff22;
      background: linear-gradient(180deg, #ffffff14, #ffffff0a);
    }
    .finalCard .label{font-size:12px; color:var(--muted); margin-bottom:8px}
    .finalCard .msg{
      font-size:18px;
      line-height:1.35;
      white-space:pre-wrap;
    }
    .small{font-size:12px; color:var(--muted)}
    .hidden{display:none !important;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="pill" id="pillLeft">
      <span class="dot"></span>
      <div style="min-width:0">
        <div class="muted">Doel</div>
        <div><strong>Raak</strong> <span class="value" id="needHits">2</span> <span class="muted">hartjes</span></div>
      </div>
    </div>

    <div class="pill" id="pillRight">
      <span class="dot"></span>
      <div style="min-width:0">
        <div class="muted">Tijd</div>
        <div><strong><span class="value" id="timeLeft">60</span>s</strong> <span class="muted">Â· Pijlen:</span> <span class="value" id="arrowsLeft">3</span></div>
      </div>
    </div>
  </div>

  <canvas id="c" width="520" height="820" aria-label="Cupid's Aim game"></canvas>

  <div class="panel">
    <div class="instructions" id="instructions">
      <div class="emoji">ðŸ’˜</div>
      <div class="txt">
        <b>Houd</b> je vinger op het scherm om te richten & kracht op te bouwen.<br/>
        <b>Laat los</b> om te schieten. Raak <b>2 hartjes</b> binnen <b>60s</b>.
      </div>
    </div>
  </div>

  <div class="overlay" id="overlayStart">
    <div class="modal">
      <h1>Cupidâ€™s Aim ðŸ’˜</h1>
      <p>Een mini Valentijns-doodle. Raak <b>2 hartjes</b> met <b>3 pijlen</b> binnen <b>60 seconden</b>.</p>
      <p class="small">Tip: richt eerst, bouw kracht op (de meter pulseert), laat los.</p>
      <div class="row">
        <button class="btn primary" id="btnStart">Start</button>
      </div>
    </div>
  </div>

  <div class="overlay hidden" id="overlayWin">
    <div class="modal">
      <h1>Je hebt raak geschoten ðŸ’˜</h1>
      <p>OkÃ©â€¦ nu mag je de kaart zien.</p>
      <div class="finalCard">
        <div class="label">Valentijnsboodschap</div>
        <div class="msg" id="finalMsg"></div>
      </div>
      <div class="row">
        <button class="btn" id="btnReplay">Opnieuw spelen</button>
      </div>
      <p class="small">P.S. Later kunnen we hier jouw definitieve tekst invullen (1 regel in de code).</p>
    </div>
  </div>

  <div class="overlay hidden" id="overlayLose">
    <div class="modal">
      <h1>Bijna! ðŸ˜„</h1>
      <p>Je was er zÃ³ dichtbij. Nog Ã©Ã©n keer?</p>
      <div class="row">
        <button class="btn primary" id="btnRetry">Opnieuw</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // =========================
  // CONFIG (later makkelijk aanpassen)
  // =========================
  const CONFIG = {
    durationSeconds: 60,
    arrowsTotal: 3,
    hitsNeeded: 2,

    // Final message placeholder: later vervangen door jouw echte tekst
    FINAL_MESSAGE: "Suzanneâ€¦ ðŸ’–\n\n(placeholder)\n\nJij bent mijn favoriete mens.\nâ€” Beat",

    // Gameplay feel
    powerPulseSpeed: 2.2,    // hoe snel de power meter pulseert
    arrowSpeedMin: 9.0,
    arrowSpeedMax: 18.0,
    heartCount: 4,
    heartMinY: 120,
    heartMaxY: 360,
  };

  // UI refs
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const overlayStart = document.getElementById('overlayStart');
  const overlayWin = document.getElementById('overlayWin');
  const overlayLose = document.getElementById('overlayLose');

  const btnStart = document.getElementById('btnStart');
  const btnReplay = document.getElementById('btnReplay');
  const btnRetry = document.getElementById('btnRetry');

  const timeLeftEl = document.getElementById('timeLeft');
  const arrowsLeftEl = document.getElementById('arrowsLeft');
  const needHitsEl = document.getElementById('needHits');
  const finalMsgEl = document.getElementById('finalMsg');
  const instructionsEl = document.getElementById('instructions');

  const pillLeft = document.getElementById('pillLeft');
  const pillRight = document.getElementById('pillRight');

  needHitsEl.textContent = CONFIG.hitsNeeded;
  finalMsgEl.textContent = CONFIG.FINAL_MESSAGE;

  // HiDPI scale for crispness
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  function resizeCanvas() {
    // Keep internal size fixed for deterministic gameplay
    // But scale for DPR
    const w = 520, h = 820;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeCanvas();

  // =========================
  // GAME STATE
  // =========================
  const W = 520, H = 820;

  let running = false;
  let startTs = 0;
  let lastTs = 0;

  let timeLeft = CONFIG.durationSeconds;
  let arrowsLeft = CONFIG.arrowsTotal;
  let hits = 0;

  // Aiming
  let aiming = false;
  let aimX = W/2;
  let aimY = H - 210;
  let holdStart = 0;
  let currentPower = 0;

  // Arrow in flight
  const arrows = [];

  // Hearts
  const hearts = [];

  // Particles / confetti
  const confetti = [];

  const cupid = {
    x: W/2,
    y: H - 150,
    r: 22
  };

  function rand(min, max) { return min + Math.random() * (max - min); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function resetGame() {
    running = false;
    startTs = 0;
    lastTs = 0;
    timeLeft = CONFIG.durationSeconds;
    arrowsLeft = CONFIG.arrowsTotal;
    hits = 0;
    aiming = false;
    holdStart = 0;
    currentPower = 0;
    arrows.length = 0;
    hearts.length = 0;
    confetti.length = 0;

    spawnHearts();
    updateHud();
    setPillStates();
  }

  function spawnHearts() {
    for (let i = 0; i < CONFIG.heartCount; i++) {
      hearts.push(makeHeart(i));
    }
  }

  function makeHeart(i) {
    const y = rand(CONFIG.heartMinY, CONFIG.heartMaxY);
    const dir = Math.random() < 0.5 ? -1 : 1;
    const speed = rand(1.2, 2.4) * dir;
    const x = dir > 0 ? rand(-120, W - 60) : rand(60, W + 120);
    return {
      x,
      y,
      r: rand(20, 30),
      vx: speed,
      bob: rand(0, Math.PI * 2),
      alive: true,
      sparkle: 0,
    };
  }

  function updateHud() {
    timeLeftEl.textContent = Math.max(0, Math.ceil(timeLeft));
    arrowsLeftEl.textContent = arrowsLeft;

    // Hide instructions after start (but keep small presence)
    if (running) instructionsEl.style.opacity = "0.85";

    setPillStates();
  }

  function setPillStates() {
    pillLeft.classList.toggle('good', hits >= CONFIG.hitsNeeded);
    pillLeft.classList.toggle('warn', hits < CONFIG.hitsNeeded);

    const urgent = timeLeft <= 15 || arrowsLeft <= 1;
    pillRight.classList.toggle('warn', urgent);
    pillRight.classList.toggle('good', !urgent);
  }

  // =========================
  // INPUT
  // =========================
  function getCanvasPoint(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    const x = (clientX - rect.left) / rect.width * W;
    const y = (clientY - rect.top) / rect.height * H;
    return { x, y };
  }

  function onDown(e) {
    if (!running) return;
    if (arrowsLeft <= 0) return;
    aiming = true;
    const p = getCanvasPoint(e);
    aimX = p.x;
    aimY = p.y;
    holdStart = performance.now();
    e.preventDefault();
  }

  function onMove(e) {
    if (!running || !aiming) return;
    const p = getCanvasPoint(e);
    aimX = p.x;
    aimY = p.y;
    e.preventDefault();
  }

  function onUp(e) {
    if (!running || !aiming) return;
    aiming = false;

    // Shoot
    if (arrowsLeft <= 0) return;
    arrowsLeft--;

    const dx = aimX - cupid.x;
    const dy = aimY - cupid.y;
    const len = Math.hypot(dx, dy) || 1;

    // Power is pulsing while holding
    const power = currentPower; // 0..1
    const speed = CONFIG.arrowSpeedMin + (CONFIG.arrowSpeedMax - CONFIG.arrowSpeedMin) * power;

    // Normalize and shoot
    const vx = (dx / len) * speed;
    const vy = (dy / len) * speed;

    arrows.push({
      x: cupid.x,
      y: cupid.y - 8,
      vx,
      vy,
      life: 0,
      alive: true
    });

    updateHud();
    e.preventDefault();
  }

  canvas.addEventListener('pointerdown', onDown, { passive:false });
  canvas.addEventListener('pointermove', onMove, { passive:false });
  canvas.addEventListener('pointerup', onUp, { passive:false });
  canvas.addEventListener('pointercancel', onUp, { passive:false });

  // Fallback touch events (older browsers)
  canvas.addEventListener('touchstart', onDown, { passive:false });
  canvas.addEventListener('touchmove', onMove, { passive:false });
  canvas.addEventListener('touchend', onUp, { passive:false });

  // =========================
  // GAME LOOP
  // =========================
  function startGame() {
    overlayStart.classList.add('hidden');
    overlayWin.classList.add('hidden');
    overlayLose.classList.add('hidden');
    instructionsEl.style.opacity = "1";

    resetGame();
    running = true;
    startTs = performance.now();
    lastTs = startTs;
    requestAnimationFrame(tick);
  }

  function endWin() {
    running = false;
    burstConfetti(W/2, H/2, 160);
    overlayWin.classList.remove('hidden');
  }

  function endLose() {
    running = false;
    overlayLose.classList.remove('hidden');
  }

  function tick(ts) {
    if (!running) {
      render(ts);
      return;
    }

    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;

    // countdown
    timeLeft = CONFIG.durationSeconds - (ts - startTs) / 1000;

    // power pulse if holding
    if (aiming) {
      const t = (ts - holdStart) / 1000;
      // Smooth pulse 0..1
      currentPower = 0.5 + 0.5 * Math.sin(t * CONFIG.powerPulseSpeed * Math.PI * 2);
      currentPower = clamp(currentPower, 0, 1);
    } else {
      currentPower = 0;
    }

    updateHearts(dt, ts);
    updateArrows(dt);
    updateConfetti(dt);

    // end conditions
    if (hits >= CONFIG.hitsNeeded) {
      endWin();
    } else if (timeLeft <= 0 || (arrowsLeft <= 0 && arrows.every(a => !a.alive))) {
      endLose();
    }

    updateHud();
    render(ts);

    if (running) requestAnimationFrame(tick);
  }

  function updateHearts(dt, ts) {
    for (const h of hearts) {
      if (!h.alive) continue;
      h.x += h.vx;
      h.bob += dt * 2.4;
      // wrap
      if (h.vx > 0 && h.x > W + 140) h.x = -140;
      if (h.vx < 0 && h.x < -140) h.x = W + 140;
      // sparkle decay
      h.sparkle = Math.max(0, h.sparkle - dt * 2.5);
    }
  }

  function updateArrows(dt) {
    for (const a of arrows) {
      if (!a.alive) continue;
      a.life += dt;
      a.x += a.vx;
      a.y += a.vy;

      // a tiny gravity for nicer arc
      a.vy += 10.0 * dt;

      // collision with hearts
      for (const h of hearts) {
        if (!h.alive) continue;
        const hx = h.x;
        const hy = h.y + Math.sin(h.bob) * 8;
        const d = Math.hypot(a.x - hx, a.y - hy);
        if (d < h.r * 0.9) {
          // hit!
          h.alive = false;
          h.sparkle = 1;
          a.alive = false;
          hits++;
          burstConfetti(hx, hy, 24);
          // respawn heart after a short moment
          setTimeout(() => {
            const idx = hearts.indexOf(h);
            if (idx >= 0) hearts[idx] = makeHeart(idx);
          }, 700);
          break;
        }
      }

      // out of bounds
      if (a.x < -60 || a.x > W + 60 || a.y < -80 || a.y > H + 80) {
        a.alive = false;
      }
    }
  }

  function burstConfetti(x, y, n) {
    for (let i = 0; i < n; i++) {
      confetti.push({
        x, y,
        vx: rand(-220, 220),
        vy: rand(-260, -60),
        r: rand(2, 4.2),
        life: rand(0.7, 1.3)
      });
    }
  }

  function updateConfetti(dt) {
    for (const p of confetti) {
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 520 * dt;
    }
    // prune
    for (let i = confetti.length - 1; i >= 0; i--) {
      if (confetti[i].life <= 0) confetti.splice(i, 1);
    }
  }

  // =========================
  // RENDER
  // =========================
  function render(ts) {
    // background stars
    ctx.clearRect(0, 0, W, H);
    drawGlowBackground(ts);

    // hearts
    for (const h of hearts) {
      if (!h.alive) continue;
      const hx = h.x;
      const hy = h.y + Math.sin(h.bob) * 8;
      drawHeart(hx, hy, h.r, h.sparkle);
    }

    // cupid + bow area
    drawCupid(cupid.x, cupid.y);

    // aiming line + power
    if (running && aiming) {
      drawAimLine(cupid.x, cupid.y - 8, aimX, aimY, currentPower);
      drawPowerMeter(currentPower);
    } else if (running) {
      drawHintArc();
    }

    // arrows
    for (const a of arrows) {
      if (!a.alive) continue;
      drawArrow(a.x, a.y, a.vx, a.vy);
    }

    // confetti
    for (const p of confetti) {
      ctx.globalAlpha = clamp(p.life, 0, 1);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fillStyle = (Math.random() < 0.5) ? "#ff4d8d" : "#ffb3d0";
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // top text inside canvas (subtle)
    drawCanvasTitle();
  }

  function drawGlowBackground(ts) {
    // soft glow blobs
    const t = ts / 1000;
    const g1x = 150 + Math.sin(t * 0.6) * 30;
    const g1y = 140 + Math.cos(t * 0.7) * 20;

    const g2x = 380 + Math.cos(t * 0.45) * 35;
    const g2y = 260 + Math.sin(t * 0.55) * 25;

    const grd1 = ctx.createRadialGradient(g1x, g1y, 10, g1x, g1y, 220);
    grd1.addColorStop(0, "rgba(255,77,141,0.18)");
    grd1.addColorStop(1, "rgba(255,77,141,0)");
    ctx.fillStyle = grd1;
    ctx.fillRect(0, 0, W, H);

    const grd2 = ctx.createRadialGradient(g2x, g2y, 10, g2x, g2y, 260);
    grd2.addColorStop(0, "rgba(255,179,208,0.14)");
    grd2.addColorStop(1, "rgba(255,179,208,0)");
    ctx.fillStyle = grd2;
    ctx.fillRect(0, 0, W, H);

    // tiny stars
    ctx.fillStyle = "rgba(255,255,255,0.09)";
    for (let i = 0; i < 60; i++) {
      const x = (i * 73) % W;
      const y = (i * 181) % H;
      const s = 1 + ((i * 19) % 2);
      ctx.globalAlpha = 0.05 + 0.07 * (0.5 + 0.5 * Math.sin(t * 0.8 + i));
      ctx.fillRect(x, y, s, s);
    }
    ctx.globalAlpha = 1;
  }

  function drawHeart(x, y, r, sparkle) {
    ctx.save();
    ctx.translate(x, y);
    const scale = 1 + sparkle * 0.08;
    ctx.scale(scale, scale);

    // glow
    ctx.beginPath();
    ctx.arc(0, 0, r*1.35, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,77,141,0.10)";
    ctx.fill();

    // heart shape
    ctx.beginPath();
    const s = r / 18;
    ctx.moveTo(0, 6*s);
    ctx.bezierCurveTo(0, -10*s, -18*s, -10*s, -18*s, 6*s);
    ctx.bezierCurveTo(-18*s, 20*s, 0, 28*s, 0, 36*s);
    ctx.bezierCurveTo(0, 28*s, 18*s, 20*s, 18*s, 6*s);
    ctx.bezierCurveTo(18*s, -10*s, 0, -10*s, 0, 6*s);
    ctx.closePath();

    const fill = ctx.createLinearGradient(0, -r, 0, r);
    fill.addColorStop(0, "#ffb3d0");
    fill.addColorStop(1, "#ff2d76");
    ctx.fillStyle = fill;
    ctx.fill();

    // highlight
    ctx.beginPath();
    ctx.ellipse(-6*s, -2*s, 5*s, 8*s, -0.3, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fill();

    ctx.restore();
  }

  function drawCupid(x, y) {
    // body glow
    ctx.beginPath();
    ctx.arc(x, y, 62, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,77,141,0.08)";
    ctx.fill();

    // tiny wings
    drawWing(x - 42, y - 12, -1);
    drawWing(x + 42, y - 12,  1);

    // head
    ctx.beginPath();
    ctx.arc(x, y - 18, 20, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fill();

    // body
    ctx.beginPath();
    ctx.roundRect(x - 18, y - 2, 36, 46, 14);
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.fill();

    // bow
    ctx.strokeStyle = "rgba(255,179,208,0.65)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y + 8, 34, -0.9, 0.9);
    ctx.stroke();

    // bow string
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x - 21, y - 16);
    ctx.lineTo(x + 21, y + 32);
    ctx.stroke();

    // little heart on chest
    drawHeart(x, y + 16, 10, 0);
  }

  function drawWing(x, y, side) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(side, 1);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.bezierCurveTo(22, -14, 34, 8, 18, 20);
    ctx.bezierCurveTo(10, 26, -2, 20, 0, 0);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.fill();
    ctx.restore();
  }

  function drawAimLine(x1, y1, x2, y2, power) {
    // clamp aim to upper half for nicer play
    const ax = clamp(x2, 20, W - 20);
    const ay = clamp(y2, 80, H - 160);

    const dx = ax - x1, dy = ay - y1;
    const len = Math.hypot(dx, dy) || 1;
    const nx = dx / len, ny = dy / len;

    // line
    ctx.strokeStyle = `rgba(255,77,141,${0.25 + power*0.55})`;
    ctx.lineWidth = 5;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(ax, ay);
    ctx.stroke();

    // arrowhead indicator
    ctx.fillStyle = `rgba(255,179,208,${0.35 + power*0.55})`;
    ctx.beginPath();
    ctx.arc(ax, ay, 9 + power*6, 0, Math.PI*2);
    ctx.fill();

    // small power text near bottom
    ctx.fillStyle = "rgba(255,255,255,0.28)";
    ctx.font = "600 12px system-ui, sans-serif";
    ctx.fillText("kracht", 20, H - 26);

    // power bar
    const barW = 110, barH = 8;
    const px = 62, py = H - 35;
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(px, py, barW, barH);
    ctx.fillStyle = "rgba(255,77,141,0.85)";
    ctx.fillRect(px, py, barW * power, barH);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.strokeRect(px, py, barW, barH);
  }

  function drawPowerMeter(power) {
    // subtle halo around cupid when power is high
    ctx.beginPath();
    ctx.arc(cupid.x, cupid.y, 85, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,77,141,${0.03 + power*0.09})`;
    ctx.fill();
  }

  function drawHintArc() {
    // gentle hint arrow pointing upward
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.font = "700 14px system-ui, sans-serif";
    ctx.fillText("tik & houd vast om te schieten", 140, H - 40);
  }

  function drawArrow(x, y, vx, vy) {
    const ang = Math.atan2(vy, vx);
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(ang);

    // shaft
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-18, 0);
    ctx.lineTo(18, 0);
    ctx.stroke();

    // tip
    ctx.fillStyle = "rgba(255,179,208,0.95)";
    ctx.beginPath();
    ctx.moveTo(18, 0);
    ctx.lineTo(10, -5);
    ctx.lineTo(10, 5);
    ctx.closePath();
    ctx.fill();

    // tail
    ctx.fillStyle = "rgba(255,77,141,0.9)";
    ctx.beginPath();
    ctx.moveTo(-18, 0);
    ctx.lineTo(-26, -6);
    ctx.lineTo(-26, 6);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function drawCanvasTitle() {
    ctx.fillStyle = "rgba(255,255,255,0.16)";
    ctx.font = "700 14px system-ui, sans-serif";
    ctx.fillText(`Hits: ${hits}/${CONFIG.hitsNeeded}`, 20, 34);
  }

  // Polyfill-ish for roundRect on some canvases
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  // =========================
  // BUTTONS
  // =========================
  btnStart.addEventListener('click', startGame);
  btnReplay.addEventListener('click', () => startGame());
  btnRetry.addEventListener('click', () => startGame());

  // Start in reset state
  resetGame();
})();
</script>
</body>
</html>
