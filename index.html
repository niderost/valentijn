<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Cupidâ€™s Aim ðŸ’˜</title>
  <style>
    :root{
      --bg1:#0b0b14;
      --bg2:#1b1030;
      --card:#ffffff12;
      --text:#f6f3ff;
      --muted:#cfc6ffcc;
      --accent:#ff4d8d;
      --accent2:#ffb3d0;
      --good:#7CFFB2;
      --warn:#ffd36e;
      --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 30% 20%, #2a1a55 0%, transparent 55%),
        radial-gradient(1000px 700px at 80% 30%, #3a1036 0%, transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow:hidden;
      touch-action:none; /* important for aiming on mobile */
    }

    .wrap{
      position:relative;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
    }

    .hud{
      position:absolute;
      top:10px;
      left:10px;
      right:10px;
      display:flex;
      gap:10px;
      align-items:stretch;
      justify-content:space-between;
      pointer-events:none;
    }

    .pill{
      pointer-events:none;
      background:var(--card);
      border:1px solid #ffffff22;
      backdrop-filter: blur(10px);
      border-radius:999px;
      padding:10px 12px;
      display:flex;
      gap:10px;
      align-items:center;
      box-shadow: 0 10px 30px #00000040;
      min-width: 0;
    }

    .pill strong{font-weight:700}
    .pill .muted{color:var(--muted); font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .pill .value{font-variant-numeric: tabular-nums; white-space:nowrap;}
    .pill .dot{
      width:10px; height:10px; border-radius:50%;
      background: #ffffff40;
      box-shadow: 0 0 0 3px #ffffff10;
      flex:0 0 auto;
    }
    .pill.good .dot{background:var(--good); box-shadow:0 0 0 3px #7cffb21a}
    .pill.warn .dot{background:var(--warn); box-shadow:0 0 0 3px #ffd36e1a}
    .pill.danger .dot{background:var(--danger); box-shadow:0 0 0 3px #ff6b6b1a}

    .panel{
      position:absolute;
      bottom:10px;
      left:10px;
      right:10px;
      display:flex;
      justify-content:center;
      pointer-events:none;
    }

    .instructions{
      pointer-events:none;
      max-width: 680px;
      width:100%;
      background:var(--card);
      border:1px solid #ffffff22;
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:12px 14px;
      box-shadow: 0 10px 30px #00000040;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .instructions .emoji{font-size:22px; line-height:1}
    .instructions .txt{font-size:14px; color:var(--muted)}
    .instructions .txt b{color:var(--text)}

    canvas{
      width:min(520px, 96vw);
      height:min(820px, 92vh);
      border-radius:22px;
      background: linear-gradient(180deg, #0b0b14 0%, #130b25 45%, #1b1030 100%);
      border:1px solid #ffffff20;
      box-shadow: 0 20px 60px #00000080;
    }

    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      pointer-events:none;
    }

    .modal{
      pointer-events:auto;
      max-width: 760px;
      width: min(760px, 92vw);
      background: #0f0a1de6;
      border:1px solid #ffffff22;
      border-radius:22px;
      box-shadow: 0 20px 80px #000000aa;
      padding:18px;
      backdrop-filter: blur(12px);
    }

    .modal h1{
      margin: 0 0 8px;
      font-size: 22px;
      letter-spacing: .2px;
    }
    .modal p{margin: 8px 0; color: var(--muted); line-height:1.35}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px}
    .btn{
      appearance:none;
      border:1px solid #ffffff26;
      background: #ffffff14;
      color: var(--text);
      padding: 11px 14px;
      border-radius: 14px;
      font-weight: 700;
      cursor:pointer;
      transition: transform .05s ease;
    }
    .btn:active{transform: scale(.98)}
    .btn.primary{
      background: linear-gradient(180deg, #ff4d8d, #ff2d76);
      border-color: #ff7cab55;
    }

    .finalCard{
      margin-top:12px;
      padding:14px;
      border-radius:18px;
      border:1px solid #ffffff22;
      background: linear-gradient(180deg, #ffffff14, #ffffff0a);
    }
    .finalCard .label{font-size:12px; color:var(--muted); margin-bottom:8px}
    .finalCard .msg{
      font-size:18px;
      line-height:1.35;
      white-space:pre-wrap;
    }
    .small{font-size:12px; color:var(--muted)}
    .hidden{display:none !important;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="pill" id="pillLeft">
      <span class="dot"></span>
      <div style="min-width:0">
        <div class="muted">Doel</div>
        <div><strong>Raak</strong> <span class="value" id="needHits">10</span> <span class="muted">hartjes</span></div>
      </div>
    </div>

    <div class="pill" id="pillRight">
      <span class="dot"></span>
      <div style="min-width:0">
        <div class="muted">Tijd</div>
        <div>
          <strong><span class="value" id="timeLeft">75</span>s</strong>
          <span class="muted">Â· Pijlen:</span> <span class="value" id="arrowsLeft">14</span>
        </div>
      </div>
    </div>
  </div>

  <canvas id="c" width="520" height="820" aria-label="Cupid's Aim game"></canvas>

  <div class="panel">
    <div class="instructions" id="instructions">
      <div class="emoji">ðŸ’˜</div>
      <div class="txt" id="instructionText">
        <b>Houd</b> je vinger op het scherm om te richten & kracht op te bouwen.<br/>
        <b>Laat los</b> om te schieten. Raak <b>10 hartjes</b>. Na <b>7</b> hits: <b>Boss Mode</b> ðŸ˜ˆ
      </div>
    </div>
  </div>

  <div class="overlay" id="overlayStart">
    <div class="modal">
      <h1>Cupidâ€™s Aim ðŸ’˜</h1>
      <p>
        Een mini Valentijns-doodle. Raak <b>10 hartjes</b> met <b>14 pijlen</b> binnen <b>75 seconden</b>.
        Na <b>7</b> hits start <b>Boss Mode</b> (decoys + sneller/kleiner).
      </p>
      <p class="small">Tip: richt eerst, bouw kracht op (de meter pulseert), laat los.</p>
      <div class="row">
        <button class="btn primary" id="btnStart">Start</button>
      </div>
    </div>
  </div>

  <div class="overlay hidden" id="overlayWin">
    <div class="modal">
      <h1>Je hebt raak geschoten ðŸ’˜</h1>
      <p>OkÃ©â€¦ nu mag je de kaart zien.</p>
      <div class="finalCard">
        <div class="label">Valentijnsboodschap</div>
        <div class="msg" id="finalMsg"></div>
      </div>
      <div class="row">
        <button class="btn" id="btnReplay">Opnieuw spelen</button>
      </div>
      <!--<p class="small">Als je de tekst later nog wilt tweaken: hij staat als Ã©Ã©n variabele in de code (FINAL_MESSAGE).</p>-->
    </div>
  </div>

  <div class="overlay hidden" id="overlayLose">
    <div class="modal">
      <h1>Bijna! ðŸ˜„</h1>
      <p>Je was er zÃ³ dichtbij. Nog Ã©Ã©n keer?</p>
      <div class="row">
        <button class="btn primary" id="btnRetry">Opnieuw</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // =========================
  // CONFIG
  // =========================
  const CONFIG = {
    durationSeconds: 75,
    arrowsTotal: 14,
    hitsNeeded: 10,

    // Final message
    FINAL_MESSAGE:
      "Lieve Suzanne,\n\n" +
      "Toch een verrassingskaart â€” voor mijn romanticus, die ik nooit teleur wil stellen.\n" +
      "Dit jaar even virtueel, omdat ik er vandaag helaas niet bij kan zijn.\n\n" +
      "Maar ook op afstand: een heleboel knuffels, en een kus.\n" +
      "Van je vriendje, dat enorm veel van je houdt.\n\n" +
      "Liefs,\n" +
      "Beat",

    // Gameplay feel
    powerPulseSpeed: 2.2,
    arrowSpeedMin: 9.0,
    arrowSpeedMax: 18.0,

    heartCount: 5,
    heartMinY: 120,
    heartMaxY: 360,

    // Boss mode
    bossStartsAtHits: 7,        // you chose 7
    bossDecoyCount: 2,
    bossSpeedMultiplier: 1.35,
    bossSizeMultiplier: 0.85,
    decoyHitTimePenalty: 6,     // seconds
    decoyJamSeconds: 0.7,       // seconds
  };

  // UI refs
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const overlayStart = document.getElementById('overlayStart');
  const overlayWin = document.getElementById('overlayWin');
  const overlayLose = document.getElementById('overlayLose');

  const btnStart = document.getElementById('btnStart');
  const btnReplay = document.getElementById('btnReplay');
  const btnRetry = document.getElementById('btnRetry');

  const timeLeftEl = document.getElementById('timeLeft');
  const arrowsLeftEl = document.getElementById('arrowsLeft');
  const needHitsEl = document.getElementById('needHits');
  const finalMsgEl = document.getElementById('finalMsg');
  const instructionsEl = document.getElementById('instructions');

  const pillLeft = document.getElementById('pillLeft');
  const pillRight = document.getElementById('pillRight');

  needHitsEl.textContent = CONFIG.hitsNeeded;
  finalMsgEl.textContent = CONFIG.FINAL_MESSAGE;

  // HiDPI scale for crispness
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  function resizeCanvas() {
    const w = 520, h = 820;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeCanvas();

  // =========================
  // GAME STATE
  // =========================
  const W = 520, H = 820;

  let running = false;
  let startTs = 0;
  let lastTs = 0;

  let timeLeft = CONFIG.durationSeconds;
  let arrowsLeft = CONFIG.arrowsTotal;
  let hits = 0;

  // Aiming
  let aiming = false;
  let aimX = W/2;
  let aimY = H - 210;
  let holdStart = 0;
  let currentPower = 0;

  // Arrow in flight
  const arrows = [];

  // Targets
  const hearts = [];
  const decoys = [];

  // Particles / confetti
  const confetti = [];

  // Boss effects
  let bossMode = false;
  let bossAnnounceUntilTs = 0;
  let jamUntilTs = 0;

  const cupid = {
    x: W/2,
    y: H - 150,
    r: 22
  };

  function rand(min, max) { return min + Math.random() * (max - min); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function resetGame() {
    running = false;
    startTs = 0;
    lastTs = 0;

    timeLeft = CONFIG.durationSeconds;
    arrowsLeft = CONFIG.arrowsTotal;
    hits = 0;

    aiming = false;
    holdStart = 0;
    currentPower = 0;

    bossMode = false;
    bossAnnounceUntilTs = 0;
    jamUntilTs = 0;

    arrows.length = 0;
    hearts.length = 0;
    decoys.length = 0;
    confetti.length = 0;

    spawnHearts();
    spawnDecoys();
    updateHud();
    setPillStates();
  }

  function spawnHearts() {
    for (let i = 0; i < CONFIG.heartCount; i++) {
      hearts.push(makeHeart(i));
    }
  }

  function spawnDecoys() {
    for (let i = 0; i < CONFIG.bossDecoyCount; i++) {
      decoys.push(makeDecoy(i));
    }
  }

  function makeHeart(i) {
    const y = rand(CONFIG.heartMinY, CONFIG.heartMaxY);
    const dir = Math.random() < 0.5 ? -1 : 1;

    const boss = bossMode; // important: use bossMode flag
    const speedBase = rand(1.2, 2.4) * dir;
    const speed = boss ? speedBase * CONFIG.bossSpeedMultiplier : speedBase;

    const x = dir > 0 ? rand(-120, W - 60) : rand(60, W + 120);
    const rBase = rand(20, 30);
    const r = boss ? rBase * CONFIG.bossSizeMultiplier : rBase;

    return {
      x,
      y,
      r,
      vx: speed,
      bob: rand(0, Math.PI * 2),
      alive: true,
      sparkle: 0,
      isDecoy: false,
    };
  }

  function makeDecoy(i) {
    const y = rand(CONFIG.heartMinY + 40, CONFIG.heartMaxY + 120);
    const dir = Math.random() < 0.5 ? -1 : 1;

    const speed = rand(1.8, 3.2) * dir;
    const x = dir > 0 ? rand(-200, W - 60) : rand(60, W + 200);

    return {
      x,
      y,
      r: rand(16, 24),
      vx: speed,
      bob: rand(0, Math.PI * 2),
      alive: true,
      sparkle: 0,
      isDecoy: true,
    };
  }

  function updateHud() {
    timeLeftEl.textContent = Math.max(0, Math.ceil(timeLeft));
    arrowsLeftEl.textContent = arrowsLeft;

    if (running) instructionsEl.style.opacity = "0.85";
    setPillStates();
  }

  function setPillStates() {
    // Left pill: progress
    pillLeft.classList.toggle('good', hits >= CONFIG.hitsNeeded);
    pillLeft.classList.toggle('warn', hits < CONFIG.hitsNeeded);
    pillLeft.classList.toggle('danger', false);

    // Right pill: urgency + jam warning
    const urgent = timeLeft <= 15 || arrowsLeft <= 2;
    const jam = (performance.now() < jamUntilTs);

    pillRight.classList.toggle('danger', jam);
    pillRight.classList.toggle('warn', !jam && urgent);
    pillRight.classList.toggle('good', !jam && !urgent);
  }

  function maybeEnterBossMode(ts) {
    if (!bossMode && hits >= CONFIG.bossStartsAtHits) {
      bossMode = true;
      bossAnnounceUntilTs = ts + 1600;
      burstConfetti(W/2, 150, 120);

      // Re-roll hearts so the "smaller/faster" feel is immediate
      for (let i = 0; i < hearts.length; i++) hearts[i] = makeHeart(i);
      // Re-roll decoys too
      for (let i = 0; i < decoys.length; i++) decoys[i] = makeDecoy(i);
    }
  }

  // =========================
  // INPUT
  // =========================
  function getCanvasPoint(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    const x = (clientX - rect.left) / rect.width * W;
    const y = (clientY - rect.top) / rect.height * H;
    return { x, y };
  }

  function onDown(e) {
    if (!running) return;
    if (arrowsLeft <= 0) return;
    if (performance.now() < jamUntilTs) return;

    aiming = true;
    const p = getCanvasPoint(e);
    aimX = p.x;
    aimY = p.y;
    holdStart = performance.now();
    e.preventDefault();
  }

  function onMove(e) {
    if (!running || !aiming) return;
    const p = getCanvasPoint(e);
    aimX = p.x;
    aimY = p.y;
    e.preventDefault();
  }

  function onUp(e) {
    if (!running || !aiming) return;

    // jam check
    if (performance.now() < jamUntilTs) { aiming = false; return; }

    aiming = false;

    // Shoot
    if (arrowsLeft <= 0) return;
    arrowsLeft--;

    const dx = aimX - cupid.x;
    const dy = aimY - cupid.y;
    const len = Math.hypot(dx, dy) || 1;

    const power = currentPower; // 0..1
    const speed = CONFIG.arrowSpeedMin + (CONFIG.arrowSpeedMax - CONFIG.arrowSpeedMin) * power;

    const vx = (dx / len) * speed;
    const vy = (dy / len) * speed;

    arrows.push({
      x: cupid.x,
      y: cupid.y - 8,
      vx,
      vy,
      alive: true
    });

    updateHud();
    e.preventDefault();
  }

  canvas.addEventListener('pointerdown', onDown, { passive:false });
  canvas.addEventListener('pointermove', onMove, { passive:false });
  canvas.addEventListener('pointerup', onUp, { passive:false });
  canvas.addEventListener('pointercancel', onUp, { passive:false });

  canvas.addEventListener('touchstart', onDown, { passive:false });
  canvas.addEventListener('touchmove', onMove, { passive:false });
  canvas.addEventListener('touchend', onUp, { passive:false });

  // =========================
  // GAME LOOP
  // =========================
  function startGame() {
    overlayStart.classList.add('hidden');
    overlayWin.classList.add('hidden');
    overlayLose.classList.add('hidden');
    instructionsEl.style.opacity = "1";

    resetGame();
    running = true;
    startTs = performance.now();
    lastTs = startTs;
    requestAnimationFrame(tick);
  }

  function endWin() {
    running = false;
    burstConfetti(W/2, H/2, 220);
    overlayWin.classList.remove('hidden');
  }

  function endLose() {
    running = false;
    overlayLose.classList.remove('hidden');
  }

  function tick(ts) {
    if (!running) {
      render(ts);
      return;
    }

    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;

    // countdown
    timeLeft = CONFIG.durationSeconds - (ts - startTs) / 1000;

    // power pulse if holding
    if (aiming) {
      const t = (ts - holdStart) / 1000;
      currentPower = 0.5 + 0.5 * Math.sin(t * CONFIG.powerPulseSpeed * Math.PI * 2);
      currentPower = clamp(currentPower, 0, 1);
    } else {
      currentPower = 0;
    }

    maybeEnterBossMode(ts);

    updateHearts(dt, ts);
    updateArrows(dt, ts);
    updateConfetti(dt);

    // end conditions
    if (hits >= CONFIG.hitsNeeded) {
      endWin();
    } else if (timeLeft <= 0 || (arrowsLeft <= 0 && arrows.every(a => !a.alive))) {
      endLose();
    }

    updateHud();
    render(ts);

    if (running) requestAnimationFrame(tick);
  }

  function updateHearts(dt, ts) {
    for (const h of hearts) {
      if (!h.alive) continue;
      h.x += h.vx;
      h.bob += dt * 2.4;

      if (h.vx > 0 && h.x > W + 140) h.x = -140;
      if (h.vx < 0 && h.x < -140) h.x = W + 140;

      h.sparkle = Math.max(0, h.sparkle - dt * 2.5);
    }

    // Decoys move only during boss mode
    if (bossMode) {
      for (const d of decoys) {
        if (!d.alive) continue;
        d.x += d.vx;
        d.bob += dt * 2.8;

        if (d.vx > 0 && d.x > W + 220) d.x = -220;
        if (d.vx < 0 && d.x < -220) d.x = W + 220;

        d.sparkle = Math.max(0, d.sparkle - dt * 2.5);
      }
    }
  }

  function updateArrows(dt, ts) {
    for (const a of arrows) {
      if (!a.alive) continue;

      a.x += a.vx;
      a.y += a.vy;

      // tiny gravity for nicer arc
      a.vy += 10.0 * dt;

      // collision with hearts
      for (const h of hearts) {
        if (!h.alive) continue;
        const hx = h.x;
        const hy = h.y + Math.sin(h.bob) * 8;
        const d = Math.hypot(a.x - hx, a.y - hy);
        if (d < h.r * 0.9) {
          h.alive = false;
          h.sparkle = 1;
          a.alive = false;

          hits++;
          burstConfetti(hx, hy, 24);

          // respawn heart after a short moment (boss settings apply via makeHeart)
          setTimeout(() => {
            const idx = hearts.indexOf(h);
            if (idx >= 0) hearts[idx] = makeHeart(idx);
          }, 650);

          break;
        }
      }

      // collision with decoys (boss mode)
      if (a.alive && bossMode) {
        for (const d of decoys) {
          if (!d.alive) continue;
          const dx = d.x;
          const dy = d.y + Math.sin(d.bob) * 7;
          const dist = Math.hypot(a.x - dx, a.y - dy);
          if (dist < d.r * 0.9) {
            d.alive = false;
            d.sparkle = 1;
            a.alive = false;

            // penalty: reduce remaining time + jam
            startTs -= CONFIG.decoyHitTimePenalty * 1000; // makes timeLeft smaller immediately
            jamUntilTs = performance.now() + CONFIG.decoyJamSeconds * 1000;

            burstConfetti(dx, dy, 18);

            setTimeout(() => {
              const idx = decoys.indexOf(d);
              if (idx >= 0) decoys[idx] = makeDecoy(idx);
            }, 850);

            break;
          }
        }
      }

      // out of bounds
      if (a.alive && (a.x < -60 || a.x > W + 60 || a.y < -80 || a.y > H + 80)) {
        a.alive = false;
      }
    }
  }

  function burstConfetti(x, y, n) {
    for (let i = 0; i < n; i++) {
      confetti.push({
        x, y,
        vx: rand(-220, 220),
        vy: rand(-260, -60),
        r: rand(2, 4.2),
        life: rand(0.7, 1.3)
      });
    }
  }

  function updateConfetti(dt) {
    for (const p of confetti) {
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 520 * dt;
    }
    for (let i = confetti.length - 1; i >= 0; i--) {
      if (confetti[i].life <= 0) confetti.splice(i, 1);
    }
  }

  // =========================
  // RENDER
  // =========================
  function render(ts) {
    ctx.clearRect(0, 0, W, H);
    drawGlowBackground(ts);

    // hearts
    for (const h of hearts) {
      if (!h.alive) continue;
      const hx = h.x;
      const hy = h.y + Math.sin(h.bob) * 8;
      drawHeart(hx, hy, h.r, h.sparkle);
    }

    // decoys (boss mode)
    if (bossMode) {
      for (const d of decoys) {
        if (!d.alive) continue;
        const dx = d.x;
        const dy = d.y + Math.sin(d.bob) * 7;
        drawBrokenHeart(dx, dy, d.r, d.sparkle);
      }
    }

    // cupid
    drawCupid(cupid.x, cupid.y);

    // aiming line + power
    if (running && aiming) {
      drawAimLine(cupid.x, cupid.y - 8, aimX, aimY, currentPower);
      drawPowerMeter(currentPower);
    } else if (running) {
      drawHintArc();
    }

    // arrows
    for (const a of arrows) {
      if (!a.alive) continue;
      drawArrow(a.x, a.y, a.vx, a.vy);
    }

    // confetti
    for (const p of confetti) {
      ctx.globalAlpha = clamp(p.life, 0, 1);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fillStyle = (Math.random() < 0.5) ? "#ff4d8d" : "#ffb3d0";
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    drawCanvasHUD(ts);
  }

  function drawGlowBackground(ts) {
    const t = ts / 1000;
    const g1x = 150 + Math.sin(t * 0.6) * 30;
    const g1y = 140 + Math.cos(t * 0.7) * 20;

    const g2x = 380 + Math.cos(t * 0.45) * 35;
    const g2y = 260 + Math.sin(t * 0.55) * 25;

    const grd1 = ctx.createRadialGradient(g1x, g1y, 10, g1x, g1y, 220);
    grd1.addColorStop(0, "rgba(255,77,141,0.18)");
    grd1.addColorStop(1, "rgba(255,77,141,0)");
    ctx.fillStyle = grd1;
    ctx.fillRect(0, 0, W, H);

    const grd2 = ctx.createRadialGradient(g2x, g2y, 10, g2x, g2y, 260);
    grd2.addColorStop(0, "rgba(255,179,208,0.14)");
    grd2.addColorStop(1, "rgba(255,179,208,0)");
    ctx.fillStyle = grd2;
    ctx.fillRect(0, 0, W, H);

    // tiny stars
    ctx.fillStyle = "rgba(255,255,255,0.09)";
    for (let i = 0; i < 60; i++) {
      const x = (i * 73) % W;
      const y = (i * 181) % H;
      const s = 1 + ((i * 19) % 2);
      ctx.globalAlpha = 0.05 + 0.07 * (0.5 + 0.5 * Math.sin(t * 0.8 + i));
      ctx.fillRect(x, y, s, s);
    }
    ctx.globalAlpha = 1;
  }

  function drawHeart(x, y, r, sparkle) {
    ctx.save();
    ctx.translate(x, y);
    const scale = 1 + sparkle * 0.08;
    ctx.scale(scale, scale);

    // glow
    ctx.beginPath();
    ctx.arc(0, 0, r*1.35, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,77,141,0.10)";
    ctx.fill();

    // heart shape
    ctx.beginPath();
    const s = r / 18;
    ctx.moveTo(0, 6*s);
    ctx.bezierCurveTo(0, -10*s, -18*s, -10*s, -18*s, 6*s);
    ctx.bezierCurveTo(-18*s, 20*s, 0, 28*s, 0, 36*s);
    ctx.bezierCurveTo(0, 28*s, 18*s, 20*s, 18*s, 6*s);
    ctx.bezierCurveTo(18*s, -10*s, 0, -10*s, 0, 6*s);
    ctx.closePath();

    const fill = ctx.createLinearGradient(0, -r, 0, r);
    fill.addColorStop(0, "#ffb3d0");
    fill.addColorStop(1, "#ff2d76");
    ctx.fillStyle = fill;
    ctx.fill();

    // highlight
    ctx.beginPath();
    ctx.ellipse(-6*s, -2*s, 5*s, 8*s, -0.3, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fill();

    ctx.restore();
  }

  function drawBrokenHeart(x, y, r, sparkle) {
    ctx.save();
    ctx.translate(x, y);
    const scale = 1 + sparkle * 0.06;
    ctx.scale(scale, scale);

    // glow
    ctx.beginPath();
    ctx.arc(0, 0, r*1.35, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.07)";
    ctx.fill();

    // heart shape (cooler palette)
    ctx.beginPath();
    const s = r / 18;
    ctx.moveTo(0, 6*s);
    ctx.bezierCurveTo(0, -10*s, -18*s, -10*s, -18*s, 6*s);
    ctx.bezierCurveTo(-18*s, 20*s, 0, 28*s, 0, 36*s);
    ctx.bezierCurveTo(0, 28*s, 18*s, 20*s, 18*s, 6*s);
    ctx.bezierCurveTo(18*s, -10*s, 0, -10*s, 0, 6*s);
    ctx.closePath();

    const fill = ctx.createLinearGradient(0, -r, 0, r);
    fill.addColorStop(0, "rgba(210,200,255,0.55)");
    fill.addColorStop(1, "rgba(140,120,210,0.65)");
    ctx.fillStyle = fill;
    ctx.fill();

    // crack
    ctx.strokeStyle = "rgba(20,10,40,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-4*s, -10*s);
    ctx.lineTo(2*s, 0*s);
    ctx.lineTo(-2*s, 10*s);
    ctx.lineTo(5*s, 22*s);
    ctx.stroke();

    ctx.restore();
  }

  function drawCupid(x, y) {
    // body glow
    ctx.beginPath();
    ctx.arc(x, y, 62, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,77,141,0.08)";
    ctx.fill();

    // wings
    drawWing(x - 42, y - 12, -1);
    drawWing(x + 42, y - 12,  1);

    // head
    ctx.beginPath();
    ctx.arc(x, y - 18, 20, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fill();

    // body
    ctx.beginPath();
    ctx.roundRect(x - 18, y - 2, 36, 46, 14);
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.fill();

    // bow
    ctx.strokeStyle = "rgba(255,179,208,0.65)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y + 8, 34, -0.9, 0.9);
    ctx.stroke();

    // bow string
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x - 21, y - 16);
    ctx.lineTo(x + 21, y + 32);
    ctx.stroke();

    // little heart
    drawHeart(x, y + 16, 10, 0);
  }

  function drawWing(x, y, side) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(side, 1);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.bezierCurveTo(22, -14, 34, 8, 18, 20);
    ctx.bezierCurveTo(10, 26, -2, 20, 0, 0);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.fill();
    ctx.restore();
  }

  function drawAimLine(x1, y1, x2, y2, power) {
    const ax = clamp(x2, 20, W - 20);
    const ay = clamp(y2, 80, H - 160);

    // line
    ctx.strokeStyle = `rgba(255,77,141,${0.25 + power*0.55})`;
    ctx.lineWidth = 5;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(ax, ay);
    ctx.stroke();

    // endpoint indicator
    ctx.fillStyle = `rgba(255,179,208,${0.35 + power*0.55})`;
    ctx.beginPath();
    ctx.arc(ax, ay, 9 + power*6, 0, Math.PI*2);
    ctx.fill();

    // power bar
    ctx.fillStyle = "rgba(255,255,255,0.28)";
    ctx.font = "600 12px system-ui, sans-serif";
    ctx.fillText("kracht", 20, H - 26);

    const barW = 110, barH = 8;
    const px = 62, py = H - 35;
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(px, py, barW, barH);
    ctx.fillStyle = "rgba(255,77,141,0.85)";
    ctx.fillRect(px, py, barW * power, barH);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.strokeRect(px, py, barW, barH);
  }

  function drawPowerMeter(power) {
    ctx.beginPath();
    ctx.arc(cupid.x, cupid.y, 85, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,77,141,${0.03 + power*0.09})`;
    ctx.fill();
  }

  function drawHintArc() {
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.font = "700 14px system-ui, sans-serif";
    ctx.fillText("tik & houd vast om te schieten", 140, H - 40);
  }

  function drawArrow(x, y, vx, vy) {
    const ang = Math.atan2(vy, vx);
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(ang);

    // shaft
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-18, 0);
    ctx.lineTo(18, 0);
    ctx.stroke();

    // tip
    ctx.fillStyle = "rgba(255,179,208,0.95)";
    ctx.beginPath();
    ctx.moveTo(18, 0);
    ctx.lineTo(10, -5);
    ctx.lineTo(10, 5);
    ctx.closePath();
    ctx.fill();

    // tail
    ctx.fillStyle = "rgba(255,77,141,0.9)";
    ctx.beginPath();
    ctx.moveTo(-18, 0);
    ctx.lineTo(-26, -6);
    ctx.lineTo(-26, 6);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function drawCanvasHUD(ts) {
    // top-left info inside canvas
    ctx.fillStyle = "rgba(255,255,255,0.16)";
    ctx.font = "700 14px system-ui, sans-serif";
    ctx.fillText(`Hits: ${hits}/${CONFIG.hitsNeeded}`, 20, 34);

    // boss mode banner
    if (bossMode) {
      ctx.fillStyle = "rgba(255,77,141,0.16)";
      ctx.font = "800 14px system-ui, sans-serif";
      ctx.fillText("BOSS MODE", W - 120, 34);
    }

    // boss announce splash
    if (bossAnnounceUntilTs && ts < bossAnnounceUntilTs) {
      const p = 1 - ((bossAnnounceUntilTs - ts) / 1600);
      const alpha = Math.sin(Math.min(1, p) * Math.PI);
      ctx.save();
      ctx.globalAlpha = 0.22 * alpha;
      ctx.fillStyle = "#ff4d8d";
      ctx.beginPath();
      ctx.roundRect(W/2 - 140, 86, 280, 54, 18);
      ctx.fill();
      ctx.globalAlpha = 0.9 * alpha;
      ctx.fillStyle = "rgba(15,10,29,0.95)";
      ctx.font = "900 18px system-ui, sans-serif";
      ctx.fillText("BOSS MODE ðŸ’¥", W/2 - 72, 120);
      ctx.restore();
    }

    // jam indicator
    const now = performance.now();
    if (now < jamUntilTs) {
      const remaining = (jamUntilTs - now) / 1000;
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      ctx.beginPath();
      ctx.roundRect(16, 52, 170, 30, 12);
      ctx.fill();
      ctx.fillStyle = "rgba(255,107,107,0.95)";
      ctx.font = "800 12px system-ui, sans-serif";
      ctx.fillText(`Oeps! Even wachtenâ€¦ ${remaining.toFixed(1)}s`, 26, 72);
      ctx.restore();
    }
  }

  // Polyfill-ish for roundRect on some canvases
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  // =========================
  // BUTTONS
  // =========================
  btnStart.addEventListener('click', startGame);
  btnReplay.addEventListener('click', () => startGame());
  btnRetry.addEventListener('click', () => startGame());

  // Start in reset state
  resetGame();
})();
</script>
</body>
</html>
